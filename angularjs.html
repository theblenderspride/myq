<!Doctype html>
<html>
<head>
	<title> Angular qs </title>	
	<script type="text/javascript" src="vendor/jquery-1.11.0.min.js"></script>
	<script type="text/javascript" src="vendor/shCore.js"></script>
	<script type="text/javascript" src="vendor/shBrushJScript.js"></script>
	<link type="text/css" rel="stylesheet" href="css/shCoreDefault.css"/>
	<link rel="stylesheet" href="css/style.css">
	<script type="text/javascript">SyntaxHighlighter.all();</script>
</head>
<body>
	<!-- <pre class="brush: js;"> -->

	<div id="container">
		
		<article class="accordion-group">
			 <div class="accordion-heading">      		
				<a href="#css-disable-text-selection" data-toggle="collapse" class="accordion-toggle">
					Angular directives - How to declare the various functions?
				</a>
			 </div>			
			 <div class="accordion-body collapse in" id="css-disable-text-selection">
				<div class="accordion-inner">
					<h1>Compile, Controller, Pre-link & Post-link</h1>
					<p>
						If one is to use all four function, the directive will follow this form:
					</p>
					<pre class="brush: js;">
						myApp.directive( 'myDirective', function () {
						    return {
						        restrict: 'EA',
						        controller: function( $scope, $element, $attrs, $transclude ) {
						            // Controller code goes here.
						        },
						        compile: function compile( tElement, tAttributes, transcludeFn ) {
						            // Compile code goes here.
						            return {
						                pre: function preLink( scope, element, attributes, controller, transcludeFn ) {
						                    // Pre-link code goes here
						                },
						                post: function postLink( scope, element, attributes, controller, transcludeFn ) {
						                    // Post-link code goes here
						                }
						            };
						        }
						    };  
						});
					</pre>	
					<p>
						Notice that compile returns an object containing both the pre-link and post-link functions; in Angular lingo we say the compile function returns a template function.
					</p>		
					<h1>
						Compile, Controller & Post-link
					</h1>	
					<p>
						If <strong>pre-link</strong> isn't necessary, the compile function can simply return the post-link function instead of a definition object, like so:
					</p>
					<pre class="brush: js;">
						myApp.directive( 'myDirective', function () {
						    return {
						        restrict: 'EA',
						        controller: function( $scope, $element, $attrs, $transclude ) {
						            // Controller code goes here.
						        },
						        compile: function compile( tElement, tAttributes, transcludeFn ) {
						            // Compile code goes here.
						            return function postLink( scope, element, attributes, controller, transcludeFn ) {
						                    // Post-link code goes here                 
						            };
						        }
						    };  
						});
					</pre>
					<p>
						Sometimes, one wishes to add a <strong>compile</strong> method, after the (post) <strong>link</strong> method was defined. For this, one can use:
					</p>
					<pre class="brush: js;">
						myApp.directive( 'myDirective', function () {
						    return {
						        restrict: 'EA',
						        controller: function( $scope, $element, $attrs, $transclude ) {
						            // Controller code goes here.
						        },
						        compile: function compile( tElement, tAttributes, transcludeFn ) {
						            // Compile code goes here.

						            return this.link;
						        },
						        link: function( scope, element, attributes, controller, transcludeFn ) {
						            // Post-link code goes here
						        }

						    };  
						});
					</pre>
					<h1>
						Controller & Post-link
					</h1>
					<p>
						If no compile function is needed, one can skip its declaration altogether and provide the post-link function under the <strong>link</strong> property of the directive's configuration object:
					</p>
					<pre class="brush: js;">
						myApp.directive( 'myDirective', function () {
						    return {
						        restrict: 'EA',
						        controller: function( $scope, $element, $attrs, $transclude ) {
						            // Controller code goes here.
						        },
						        link: function postLink( scope, element, attributes, controller, transcludeFn ) {
						                // Post-link code goes here                 
						        },          
						    };  
						});
					</pre>
					<h1>No controller</h1>
					<p>
						In any of the examples above, one can simply remove the <strong>controller</strong> function if not needed. So for instance, if only <strong>post-link</strong> function is needed, one can use:
					</p>
				</div>
			</div>
		</article>

		<article class="accordion-group">
			 <div class="accordion-heading">      		
				<a href="#css-disable-text-selection" data-toggle="collapse" class="accordion-toggle">
					In which order the directive functions are executed?
				</a>
			 </div>			
			 <div class="accordion-body collapse in">
				<div class="accordion-inner">
					<h1>For a single directive</h1>
					<p>
						Based on the following plunk, consider the following HTML markup:
					</p>
					<pre class="brush: js;">
						<body>
						    <div log='some-div'></div>
						</body>
					</pre>	
					<p>With the following directive declaration:</p>
					<pre class="brush: js;">
						myApp.directive('log', function() {
						    return {
						        controller: function( $scope, $element, $attrs, $transclude ) {
						            console.log( $attrs.log + ' (controller)' );
						        },
						        compile: function compile( tElement, tAttributes ) {
						            console.log( tAttributes.log + ' (compile)'  );
						            return {
						                pre: function preLink( scope, element, attributes ) {
						                    console.log( attributes.log + ' (pre-link)'  );
						                },
						                post: function postLink( scope, element, attributes ) {
						                    console.log( attributes.log + ' (post-link)'  );
						                }
						            };
						         }
						     };  

						});
					</pre>		
					<p>
						The console output will be:
					</p>	
					<pre class="brush: js;">
						some-div (compile)
						some-div (controller)
						some-div (pre-link)
						some-div (post-link)
					</pre>
					<p>We can see that compile is executed first, then controller, then pre-link and finally followed by post-link.</p>
					<h1>
						For nested directives
					</h1>
					<pre class="brush: js;">
						Note: The following does not apply to directives that render their children in their link function. Quite a few Angular directives (like ngIf, ngRepeat, or any directive with transclude) do so. These type of directives will natively have their link function called before their child directives compile is called.
					</pre>
					<p>The original HTML markup is often made of nested elements, each with its own directive. Like in the following markup (see plunk):</p>
					<pre class="brush: js;">
						<body>
						    <div log='parent'>
						        <div log='..first-child'></div>
						        <div log='..second-child'></div>
						    </div>
						</body>
					</pre>
					<p>
						The console output will look like this (without the comments):
					</p>
					<pre class="brush: js;">
						// The compile phase
						parent (compile)
						..first-child (compile)
						..second-child (compile)

						// The link phase   
						parent (controller)
						parent (pre-link)
						..first-child (controller)
						..first-child (pre-link)
						..first-child (post-link)
						..second-child (controller)
						..second-child (pre-link)
						..second-child (post-link)
						parent (post-link)
					</pre>
					<p>
						We can distinguish two phases here - the compile phase and the link phase.
					</p>
					<h1>The compile phase</h1>
					<p>
						When the DOM is loaded Angular starts the compile phase, where it traverses the markup top-down, and calls compile on all directives. Graphically, we could express it like so:
					</p>
					<div>
						<img src="img/compile-phase.png" alt="">
					</div>
					<p>It is perhaps important to mention that at this stage, the templates the compile function gets are the source templates (not instance template).</p>
					<h1>
						The link phase
					</h1>
					<p>
						DOM instances are often simply the result of a source template being rendered to the DOM, but they may be created by ng-repeat, or introduced on the fly.
					</p>
					<p>
						Whenever a new instance of an element with a directive is rendered to the DOM, the link phase starts.
					</p>
					<p>In this phase, Angular calls controller, pre-link, iterates children, and call post-link on all directives, like so:</p>
					<div>
						<img src="img/link-phase.png" alt="">
					</div>
				</div>
			</div>
		</article>

	</div>

	<article class="accordion-group">
			 <div class="accordion-heading">      		
				<a href="#css-disable-text-selection" data-toggle="collapse" class="accordion-toggle">
					What is the difference between a source template and an instance template?
				</a>
			 </div>			
			 <div class="accordion-body collapse in" id="css-disable-text-selection">
				<div class="accordion-inner">
					<p>The fact that Angular allows DOM manipulation means that the input markup into the compilation process sometimes differ from the output. Particularly, some input markup may be cloned a few times (like with ng-repeat) before being rendered to the DOM.</p>
					<p>
						Angular terminology is a bit inconsistent, but it still distinguishes between two types of markups:
					</p>
					<ul>
						<li>
							<strong>Source template</strong> - the markup to be cloned, if needed. If cloned, this markup will not be rendered to the DOM.
						</li>
						<li>
							<strong>Instance template</strong> - the actual markup to be rendered to the DOM. If cloning is involved, each instance will be a clone.
						</li>
					</ul>
					<p>The following markup demonstrates this:</p>
					<pre class="brush: js;">
						<div ng-repeat="i in [0,1,2]">
						    <my-directive>{{i}}</my-directive>
						</div>
					</pre>
					<p>The source html defines</p>
					<pre class="brush: js;">
						    <my-directive>{{i}}</my-directive>
					</pre>	
					<p>which serves as the source template</p>			
					<p>But as it is wrapped within an ng-repeat directive, this source template will be cloned (3 times in our case). These clones are instance template, each will appear in the DOM and be bound to the relevant scope.</p>

				</div>
			</div>
		</article>

		<article class="accordion-group">
			 <div class="accordion-heading">      		
				<a href="#css-disable-text-selection" data-toggle="collapse" class="accordion-toggle">
				Function nature, do's and dont's
				</a>
			 </div>			
			 <div class="accordion-body collapse in" id="css-disable-text-selection">
				<div class="accordion-inner">
					<h1>Compile</h1>
					<p>Each directive's compile function is only called once, when Angular bootstraps.</p>
					<p>
						Officially, this is the place to perform (source) template manipulations that do not involve scope or data binding.
					</p>
					<p>
					Primarily, this is done for optimisation purposes; consider the following markup:
					</p>
					<pre class="brush: js;">
						<tr ng-repeat="raw in raws">
						    <my-raw></my-raw>
						</tr>
					</pre>	
					<p>
						The <my-raw> directive will render a particular DOM Markup. So we can either:
					</p>			
					<ul>
						<li>
							Allow ng-repeat to duplicate the source template (<my-raw>), only then modify the markup of each instance template (outside the compile function).
						</li>
						<li>
							First modify the source template to involve the desired markup (in the compile function), only then allow ng-repeat duplicating it.
						</li>
					</ul>
					<p>
						If there are 1000 raws, the latter option may be faster than the former one.
					</p>
					<h1>Do's</h1>
					<ul>
						<li>
							Manipulate markup so it serves as a template to instances (clones).
						</li>
					</ul>
					<h1>Dont's</h1>
					<ul>
						<li>
							Attach event handlers..
						</li>
						<li>
							Inspect child elements.
						</li>
						<li>
							Setup observations on attributes.
						</li>
						<li>
							Setup watches on the scope.
						</li>
					</ul>
				</div>
			</div>
		</article>

	<!-- end of container-->
	
	<script type="text/javascript" src="js/App.js"></script>
	
</body>
</html>